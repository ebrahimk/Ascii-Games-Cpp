Reflection:
	
	For this Reflection document I am going to walk through my process for coding this assignment. I used the OpenSpace, Wall,MazeLocation, and Maze classes we implemeted in lab 9 as the starting point for this assignment, so all the code for those classes was already written and I had a rough idea of what my code was going to look like. Based of the description of the assignment I realized that I would have to keep track of two things simultaneously that essentially could run independant of one another. These two things were the visual representation of the board, so how the symbols interact as the player inputs responses, and the locaitons of the maze people objects I created. Because the MazeLocation class had no maze person member every time I wrote code that updated the visual representation of the maze I had to write extra code that updated the location of each maze person object. When I realized a decent method of accomplishing this the code wrote itself so to say. Some particularly nice design elements I implemeted are seen in my Maze constructor where I initialize an array of MazeLevels equal to the number of levels readi nfrom the text file. I also created an array of TA objects. Another nice design element I implemented was the use of the "floor" member in all of my MazePerson classes. The "floor" member allowed me to track which maze level my different objects were on. You dont see it when you actually run the code, but if their was a function that printed all of the levels of the maze you would see that the TA' on all floors move around regardless of what floor the player is on. Essentially in my maze constructor I read in the entire maze.txt file and create the entire funcitoning maze with all of the objects placed as outlined in the assignment instructions. 

	Speaking on my program design: the program begins by initializing a pointer to a new maze, I did this so, in case the player loses, I could just delete the current Maze object the player was in and create another new Maze. Inside the Maze constructor a few things happen. First the level number, height nad width are read into the file after opening in the text file. This information is used to create an array of new MazeLevel objects equal to the level num. These MazeLevel objects are initialized by reading in each line of the text file, converting that file to a c-string and comparing the characters of said c-string to the characters of the maze. This is accomplished through a filter of "if" statements. As the comparisons return true, depending on whether or not the character represents an OpenSpace or Wall, the constructors for these respective objects is called, initializing the "symbol" member of each MazeLocation object. The filter of "if" statements also checks for the ladder and start symbols and initializes specific MazeLocations to have these properties. After the array of MazeLevels is filled the Maze constructor initializes a new Instructor and IntrepidStudent, in the constructor for these objects they are set o specific floors. Next, an array of six TA objects are created, the array of MazeLevels is looped though placing two TA obejects on each floor. There is no Skill class for this code, so the properties of skills is largely programmed based of character comparisions. The array of MazeLevels is again looped through changing the symbol of three MazeLocation OpenSpaces to "$", and setting the OpenSpace member "set_has_skill() to true". During the process of initializing the location of the MAzePerson objects their corresponding position on the grid is updated to contain their symbol. 
	
	The next function is the Maze::turn(). This function calls the IntrepidStudent get_move() method and returns a charaters either 'w', 's', 'd', 'a', 'u', 'p' and does error checking on the inputs. With this character the method executes a given event. In the case of a move the methods checks to make sure the move is valid, then updates the grid symbols and the location of the IntrepidStudent objects. The next method is the turn_ta() method which loops through the TA objects array calling the get_move() method for each TA. The move character is contiuously generated randomly until a valid move character is returned. The grid is then updated as are the locations of the TA objects (row_loc, and clo_loc). 
 
	The next method is the Maze::chack_ta(). This method checks each adjacent space to the IntrepidStudent object for the TA bool member in an OpenSpace. If one of the locations returns true then then the function verifies that the TA in said location has a "false" appeased status. If this is true and the TA is not appeased the TA's, student and skills are randomly moved to OpenSpaces and the player returns to the start. The player can demonstrate skills if the player has any. When the player demonstrates a skill, I loop through the TA array and compare the floor member integer of the TA's with the floor integer of the IntrepidStudent. If the TA and Student have the same floor number (they are on the same level of the maze) then I call the TA member counter_Set() which sets the class member "counter" to ten and "appeased" bool to true. The next method is Maze::check_win() which simply checks to see whether or not the IntrpidStudent object is adjacent to the professor, if so the method chacks the IntrepidStudents skill member. If this member is above three, the student wins, if the member is below 3 the student loses, the new Maze is deleted in a while loop and another new Maze is initialized, and the game starts over. At the end of each turn the method Maze::display() is called, this function merely prints the MazeLevel that the player is on based on the players "floor" member.  

	This assignment definitley took a decent amount of my time. I think I logged in roughly 16 diligent-ish hours on it. The program satisfies all of the criteria as laid out in the rubric but I definitely did encouter some difficulties while writing the code. For these past few assignments I've been writing all of the code before testing it to see it works, so when I finally finish and try to compile, I get a TON of error messages, usually they are just small things like missing semicolons or missing "()" when calling method, but their are usually two or three errors which are generated by flaws in the logic of the code that take a decent amount of time to completely correct. For this assignment I kept running into errors when trying to read in my file one character at a time with the .get() method. I never actually got my code to work with that method so I tried reading in line after line with getline(). This I got to work properly. I simply read in each line, converted it ot a c-string and then looped through the length of the line comparing characters to initialize their respective objects. 

	Another error I encounter was freeing all of the memory I allocated in my MazeLevel class. I couldnt figure out why all of the memory was not being freed and eventually realized that I was not deleting the array of MazeLocaiton* which pointed to the new OpenSpaces or new Walls. 
 
	I think I sometimes cheat myself when I write code. I particularly felt this way when writing my Maze.cpp file. their were quite a few methods which I simply coded out that could have been implemented in a funcito nso as to conserve space complexity. However I am not too worked up about this, my program works properly though it could definitely have been condensed. In all it was a fun assignment, I think I liked Hunt the Wumpus more but this assignments was a little more comprehensive and jogged my memory a bit since we had to read in from a text file. Big shout out to all the TA's for 162, you guys were a big help and outstanding resource. Best of luck in the Spring!

P.S. sorry for the horrible spelling, my text editor doesnt allow me to set my cursor manually so I have to loop through text with the arrow keys and it takes a long time. 

-Kamron     
